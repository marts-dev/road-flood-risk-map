{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to road_flood_risk_map","text":"<p>A python package for doing flood risk analysis of roads.</p> <ul> <li>Built on top of geemap and WbW</li> <li>Free software: MIT License</li> <li>Documentation: https://marts-dev.github.io/road_flood_risk_map</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Perform D8 Flow Analysis and Flow Accumulation</li> </ul>"},{"location":"#under-development","title":"Under Development","text":"<ul> <li>Road map overlay with flow accumulation</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>Lindsay, J. B., &amp; Whitebox Geospatial Inc. (2025). whitebox_workflows (Version 1.3.5) [Software]. Available at: https://pypi.org/project/whitebox-workflows/ Wu, Q. (2020). geemap: A Python package for interactive mapping with Google Earth Engine. Journal of Open Source Software, 5(51), 2305. https://doi.org/10.21105/joss.02305</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#road_flood_risk_map.common.compute_d8_direction","title":"<code>compute_d8_direction(dem, nodata_value=nan)</code>","text":"<p>Compute D8 flow direction from a DEM.</p> Source code in <code>road_flood_risk_map/common.py</code> <pre><code>def compute_d8_direction(dem, nodata_value=np.nan):\n    \"\"\"Compute D8 flow direction from a DEM.\"\"\"\n    # Placeholder for D8 direction computation logic\n    # This should return a numpy array of the same shape as dem\n    # with values indicating the flow direction.\n    direction_code = {\n        32: (-1, -1),  # 0: North-West\n        64: (-1, 0),  # 1: North\n        128: (-1, 1),  # 2: North-East\n        1: (0, 1),  # 3: East\n        2: (1, 1),  # 4: South-East\n        4: (0, 1),  # 5: South\n        8: (1, -1),  # 6: South-West\n        16: (0, -1),  # 7: West\n    }\n    d8_direction = np.zeros_like(dem, dtype=np.int32)\n    rows, cols = dem.shape\n    for i in range(0, rows):\n        for j in range(0, cols):\n            if dem[i, j] == nodata_value:  # Assuming -9999 is the nodata value\n                d8_direction[i, j] = nodata_value\n            else:\n                # Compute the direction based on the surrounding cells\n                maximum_drop = -np.inf\n                elev = dem[i, j]\n                direction = -1\n                for k, (di, dj) in direction_code.items():\n                    ni, nj = i + di, j + dj\n                    if 0 &lt;= ni &lt; rows and 0 &lt;= nj &lt; cols:\n                        # maximum_drop = change_in_z-value / distance * 100\n                        change_in_z = elev - dem[ni, nj]\n                        distance = np.sqrt(di**2 + dj**2)\n                        drop = (change_in_z / distance * 100) if distance != 0 else 0\n                        if drop &gt; maximum_drop:\n                            maximum_drop = drop\n                            direction = k\n                d8_direction[i, j] = direction\n    return d8_direction\n</code></pre>"},{"location":"common/#road_flood_risk_map.common.fill_depression_epsilon","title":"<code>fill_depression_epsilon(dem, nodata_value=-9999)</code>","text":"<p>Fill depressions in a DEM using an epsilon-based approach.</p> Source code in <code>road_flood_risk_map/common.py</code> <pre><code>def fill_depression_epsilon(dem, nodata_value=-9999):\n    \"\"\"\n    Fill depressions in a DEM using an epsilon-based approach.\n    \"\"\"\n    import heapq\n    import numpy as np\n    import queue\n\n    filled_dem = dem.copy()\n    rows, cols = dem.shape\n    open_pq = []\n    pits = queue.Queue()\n    closed_set = np.zeros((rows, cols), dtype=bool)\n\n    neighbors = [\n        (-1, 0),  # North\n        (1, 0),  # South\n        (0, -1),  # West\n        (0, 1),  # East\n        (-1, -1),  # Northwest\n        (-1, 1),  # Northeast\n        (1, -1),  # Southwest\n        (1, 1),  # Southeast\n    ]\n\n    # Initialize the priority queue with border cells\n    for i in range(rows):\n        heapq.heappush(open_pq, (dem[i, 0], (i, 0)))\n        heapq.heappush(open_pq, (dem[i, cols - 1], (i, cols - 1)))\n        closed_set[i, 0] = True\n        closed_set[i, cols - 1] = True\n\n    for j in range(1, cols - 1):\n        heapq.heappush(open_pq, (dem[0, j], (0, j)))\n        heapq.heappush(open_pq, (dem[rows - 1, j], (rows - 1, j)))\n        closed_set[0, j] = True\n        closed_set[rows - 1, j] = True\n\n    pit_top = None\n    false_pit_cells = 0\n    while open_pq or not pits.empty():\n        current = None\n\n        if open_pq and (open_pq[0][0] == pit_top):\n            current = heapq.heappop(open_pq)\n            pit_top = None\n        elif not pits.empty():\n            current = pits.get()\n            if pit_top is None:\n                pit_top = dem[current[1][0], current[1][1]]\n        else:\n            current = heapq.heappop(open_pq)\n            pit_top = None\n\n        # Process neighbors of current cell\n        for dx, dy in neighbors:\n            nx, ny = current[1][0] + dx, current[1][1] + dy\n            if 0 &lt;= nx &lt; rows and 0 &lt;= ny &lt; cols and not closed_set[nx, ny]:\n                neighbor_value = dem[nx, ny]\n\n                closed_set[nx, ny] = True\n                if neighbor_value == nodata_value or np.isnan(neighbor_value):\n                    pits.put((neighbor_value, (nx, ny)))\n                elif neighbor_value &lt;= np.nextafter(current[0], np.float64(\"inf\")):\n                    next_after_value = np.nextafter(current[0], np.float64(\"inf\"))\n                    if pit_top is not None and (\n                        pit_top &lt; neighbor_value and next_after_value &gt;= neighbor_value\n                    ):\n                        false_pit_cells += 1\n                    filled_dem[nx, ny] = next_after_value\n                    pits.put((neighbor_value, (nx, ny)))\n                else:\n                    # Otherwise, add to open set\n                    heapq.heappush(open_pq, (neighbor_value, (nx, ny)))\n\n    return filled_dem\n</code></pre>"},{"location":"common/#road_flood_risk_map.common.fill_depressions","title":"<code>fill_depressions(dem)</code>","text":"<p>Fill depressions in a DEM using a simple algorithm.</p> Source code in <code>road_flood_risk_map/common.py</code> <pre><code>def fill_depressions(dem):\n    \"\"\"\n    Fill depressions in a DEM using a simple algorithm.\n    \"\"\"\n    import heapq\n    import numpy as np\n    import queue\n\n    filled_dem = dem.copy()\n    rows, cols = dem.shape\n    open_pq = []\n    pits = queue.Queue()\n    closed_set = np.zeros((rows, cols), dtype=bool)\n\n    neighbors = [\n        (-1, 0),  # North\n        (1, 0),  # South\n        (0, -1),  # West\n        (0, 1),  # East\n        (-1, -1),  # Northwest\n        (-1, 1),  # Northeast\n        (1, -1),  # Southwest\n        (1, 1),  # Southeast\n    ]\n\n    # Initialize the priority queue with border cells\n    for i in range(rows):\n        heapq.heappush(open_pq, (dem[i, 0], (i, 0)))\n        heapq.heappush(open_pq, (dem[i, cols - 1], (i, cols - 1)))\n        closed_set[i, 0] = True\n        closed_set[i, cols - 1] = True\n\n    for j in range(1, cols - 1):\n        heapq.heappush(open_pq, (dem[0, j], (0, j)))\n        heapq.heappush(open_pq, (dem[rows - 1, j], (rows - 1, j)))\n        closed_set[0, j] = True\n        closed_set[rows - 1, j] = True\n\n    while open_pq or not pits.empty():\n        current = None\n        if not pits.empty():\n            current = pits.get()\n        else:\n            current = heapq.heappop(open_pq)\n\n        # Process neighbors of current cell\n        for dx, dy in neighbors:\n            nx, ny = current[1][0] + dx, current[1][1] + dy\n            if 0 &lt;= nx &lt; rows and 0 &lt;= ny &lt; cols and not closed_set[nx, ny]:\n                neighbor_value = dem[nx, ny]\n\n                closed_set[nx, ny] = True\n                if neighbor_value &lt;= current[0]:\n                    # If neighbor is lower, add to pits\n                    filled_dem[nx, ny] = current[0]\n                    pits.put((neighbor_value, (nx, ny)))\n                else:\n                    # Otherwise, add to open set\n                    heapq.heappush(open_pq, (neighbor_value, (nx, ny)))\n\n    return filled_dem\n</code></pre>"},{"location":"common/#road_flood_risk_map.common.fill_depressions_flow_dirs","title":"<code>fill_depressions_flow_dirs(dem)</code>","text":"<p>Fill depressions in a DEM using a simple algorithm.</p> Source code in <code>road_flood_risk_map/common.py</code> <pre><code>def fill_depressions_flow_dirs(dem):\n    \"\"\"\n    Fill depressions in a DEM using a simple algorithm.\n    \"\"\"\n    import heapq\n    import numpy as np\n    import queue\n\n    def get_opposite_direction(x, y):\n        \"\"\"Get the opposite direction for a given D8 direction.\"\"\"\n        return [-x, -y]\n\n    rows, cols = dem.shape\n    open_pq = []\n    closed_set = np.zeros((rows, cols), dtype=bool)\n    flow_dirs = np.zeros_like(dem, dtype=np.int32)\n\n    direction_code = {\n        (-1, 0): 64,  # 1: North\n        (0, 1): 1,  # 3: East\n        (0, 1): 4,  # 5: South\n        (0, -1): 16,  # 7: West\n        (-1, -1): 32,  # 0: North-West\n        (-1, 1): 128,  # 2: North-East\n        (1, 1): 2,  # 4: South-East\n        (1, -1): 8,  # 6: South-West\n    }\n\n    # Initialize the priority queue with border cells\n    for i in range(rows):\n        heapq.heappush(open_pq, (dem[i, 0], (i, 0)))\n        heapq.heappush(open_pq, (dem[i, cols - 1], (i, cols - 1)))\n        closed_set[i, 0] = True\n        if np.isnan(dem[i, 0]):\n            flow_dirs[i, 0] = None\n        else:\n            flow_dirs[i, 0] = 1\n        closed_set[i, cols - 1] = True\n        if np.isnan(dem[i, cols - 1]):\n            flow_dirs[i, cols - 1] = None\n        else:\n            flow_dirs[i, cols - 1] = 16\n\n    for j in range(1, cols - 1):\n        heapq.heappush(open_pq, (dem[0, j], (0, j)))\n        heapq.heappush(open_pq, (dem[rows - 1, j], (rows - 1, j)))\n        closed_set[0, j] = True\n        if np.isnan(dem[0, j]):\n            flow_dirs[0, j] = None\n        else:\n            flow_dirs[0, j] = 64\n        closed_set[rows - 1, j] = True\n        if np.isnan(dem[rows - 1, j]):\n            flow_dirs[rows - 1, j] = None\n        else:\n            flow_dirs[rows - 1, j] = 4\n\n    while open_pq:\n        current = heapq.heappop(open_pq)\n\n        # Process neighbors of current cell\n        for (dx, dy), direction in direction_code.items():\n            nx, ny = current[1][0] + dx, current[1][1] + dy\n            if 0 &lt;= nx &lt; rows and 0 &lt;= ny &lt; cols and not closed_set[nx, ny]:\n                neighbor_value = dem[nx, ny]\n                if np.isnan(neighbor_value):\n                    flow_dirs[nx, ny] = None\n                else:\n                    ox, oy = get_opposite_direction(nx, ny)\n                    flow_dirs[nx, ny] = direction[(ox, oy)]\n                closed_set[nx, ny] = True\n                heapq.heappush(open_pq, (neighbor_value, (nx, ny)))\n\n    return flow_dirs\n</code></pre>"},{"location":"common/#road_flood_risk_map.common.fix_raster_metadata","title":"<code>fix_raster_metadata(file_name, output_name)</code>","text":"<p>Converts the compress method string of the Raster file to uppercase as supported by WhiteBoxTools.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Raster file to modify</p> required <code>output_name</code> <code>str</code> <p>Output raster file name without extension</p> required <p>Returns:</p> Type Description <code>path (str)</code> <p>Full path of the output raster file</p> Source code in <code>road_flood_risk_map/common.py</code> <pre><code>def fix_raster_metadata(file_name: str, output_name: str):\n    \"\"\"\n    Converts the compress method string of the Raster file to uppercase as supported by WhiteBoxTools.\n\n    Args:\n        file_name (str): Raster file to modify\n        output_name (str): Output raster file name without extension\n\n    Returns:\n        path (str): Full path of the output raster file\n    \"\"\"\n    import rasterio\n    from rasterio.transform import Affine\n    import os\n\n    with rasterio.open(file_name) as src:\n        profile = src.profile.copy()\n        profile.update(compress=profile[\"compress\"].upper())\n        profile.update(nodata=-9999)\n        bounds = src.bounds\n        # Fix bounds\n        shift = 0\n        if bounds.left &lt; -180:\n            shift = 360\n        elif bounds.right &gt; 180:\n            shift = -360\n        if shift != 0:\n            new_transform = Affine.translation(shift, 0) * src.transform\n            profile.update(transform=new_transform)\n            print(f\"Fixed bounds by shifting {shift} degrees.\")\n        with rasterio.open(f\"{output_name}.tif\", \"w\", **profile) as dst:\n            dst.write(src.read())\n    os.remove(file_name)\n    return f\"{os.path.join(os.getcwd(),output_name)}.tif\"\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/marts-dev/road-flood-risk-map/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>road-flood-risk-map could always use more documentation, whether as part of the official road-flood-risk-map docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/marts-dev/road-flood-risk-map/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up road-flood-risk-map for local development.</p> <ol> <li> <p>Fork the road-flood-risk-map repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/road-flood-risk-map.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv road-flood-risk-map\n$ cd road-flood-risk-map/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 road-flood-risk-map tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/marts-dev/road-flood-risk-map/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install road-flood-risk-map, run this command in your terminal:</p> <pre><code>pip install road-flood-risk-map\n</code></pre> <p>This is the preferred method to install road-flood-risk-map, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install road-flood-risk-map from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/marts-dev/road-flood-risk-map\n</code></pre>"},{"location":"road_flood_risk_map/","title":"road_flood_risk_map module","text":"<p>Main module.</p>"},{"location":"road_flood_risk_map/#road_flood_risk_map.road_flood_risk_map.RoadFloodRiskMap","title":"<code> RoadFloodRiskMap            (Map)         </code>","text":"<p>A class to represent a road flood risk map.</p> Source code in <code>road_flood_risk_map/road_flood_risk_map.py</code> <pre><code>class RoadFloodRiskMap(geemap.Map):\n    \"\"\"A class to represent a road flood risk map.\"\"\"\n\n    def __init__(\n        self,\n        basemap=\"SATELLITE\",\n        center=[40, -100],\n        zoom=4,\n        height=\"600px\",\n        add_google_map=False,\n        verbose=False,\n    ):\n        \"\"\"\n        Initialize the RoadFloodRiskMap with map data.\n\n        Args:\n            basemap (str): The basemap to use. Default is \"SATELLITE\". Other options include \"ROADMAP\", \"TERRAIN\", \"HYBRID\", etc.\n            center (list): The center of the map as a list of [latitude, longitude]. Default is [40, -100].\n            zoom (int): The initial zoom level of the map. Default is 4.\n            height (str): The height of the map in CSS units. Default is \"600px\".\n            add_google_map (bool): Whether to add Google Maps basemap. Default is False.\n            verbose (bool): Whether to print verbose output. Default is False.\n        \"\"\"\n        geemap.ee_initialize()  # Initialize Earth Engine\n        super().__init__(\n            basemap=basemap,\n            center=center,\n            zoom=zoom,\n            height=height,\n            add_google_map=add_google_map,\n        )\n        self.wbe = WbEnvironment()\n        self.wbe.verbose = verbose\n        self.wbe.working_directory = (\n            os.getcwd()\n        )  # Set the working directory to the current directory\n\n    def retrieve_alos_palsar_data_clip(\n        self,\n        region_of_interest: ee.Geometry,\n        output_file_name: str | None = None,\n        scale: int = 30,\n    ):\n        \"\"\"\n        Retrieve ALOS PALSAR data clipped to a region of interest. If `output_file_name` is provided, the data will be saved to a file.\n\n        Args:\n            region_of_interest (Geometry.BBox): The region to clip the ALOS PALSAR data to. It follows the following format: `ee.Geometry.BBox(west, south, east, north)`. **west** The westernmost enclosed longitude. Will be adjusted to lie in the range -180\u00b0 to 180\u00b0. **south** The southernmost enclosed latitude. If less than -90\u00b0 (south pole), will be treated as -90\u00b0. **east** The easternmost enclosed longitude. **north** The northernmost enclosed latitude. If greater than +90\u00b0 (north pole), will be treated as +90\u00b0.\n            output_file_name (str | None): The name of the output file to save the data. If None, the data will not be saved to a file.\n            scale (int): The scale in meters at which to export the image. Default is 30.\n\n        Returns:\n            image: The ALOS PALSAR data clipped to the region of interest.\n        \"\"\"\n        # Placeholder for actual data retrieval logic\n        sarHh = (\n            ee.ImageCollection(\"JAXA/ALOS/PALSAR/YEARLY/SAR_EPOCH\")\n            .filter(ee.Filter.date(\"2017-01-01\", \"2018-01-01\"))\n            .select(\"HH\")\n        )\n\n        if output_file_name != None or output_file_name != \"\":\n            try:\n                geemap.ee_export_image(\n                    sarHh.mean(),\n                    filename=output_file_name + \".tif\",\n                    region=region_of_interest,\n                    scale=scale,\n                )\n            except Exception as e:\n                print(f\"Error exporting image: {e}\")\n\n        return sarHh.mean().clip(region_of_interest)\n\n    def retrieve_sentinel_1_data_clip(\n        self,\n        region_of_interest: ee.Geometry,\n        output_file_name: str | None = None,\n        scale: int = 30,\n    ):\n        \"\"\"\n        Retrieve Sentinel-1 data clipped to a region of interest. If `output_file_name` is provided, the data will be saved to a file.\n\n        Args:\n            region_of_interest (Geometry.BBox): The region to clip the Sentinel-1 data to. It follows the following format: `ee.Geometry.BBox(west, south, east, north)`. **west** The westernmost enclosed longitude. Will be adjusted to lie in the range -180\u00b0 to 180\u00b0. **south** The southernmost enclosed latitude. If less than -90\u00b0 (south pole), will be treated as -90\u00b0. **east** The easternmost enclosed longitude. **north** The northernmost enclosed latitude. If greater than +90\u00b0 (north pole), will be treated as +90\u00b0.\n            output_file_name (str | None): The name of the output file to save the data. If None, the data will not be saved to a file.\n            scale (int): The scale in meters at which to export the image. Default is 30.\n\n        Returns:\n            image: The Sentinel-1 data clipped to the region of interest.\n        \"\"\"\n        # Placeholder for actual data retrieval logic\n        sentinel1 = (\n            ee.ImageCollection(\"COPERNICUS/S1_GRD\")\n            .filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VH\"))\n            .filter(ee.Filter.date(\"2024-06-01\", \"2025-06-01\"))\n            .filter(ee.Filter.eq(\"resolution_meters\", scale))\n            .select(\"VH\")\n        )\n\n        if output_file_name != None and output_file_name != \"\":\n            try:\n                geemap.ee_export_image(\n                    sentinel1.mean(),\n                    filename=output_file_name + \".tif\",\n                    region=region_of_interest,\n                    scale=scale,\n                )\n            except Exception as e:\n                print(f\"Error exporting image: {e}\")\n\n        return sentinel1.mean().clip(region_of_interest)\n\n    def perform_hydrological_analysis(self, input_dem_file: str):\n        \"\"\"\n        Perform a hydrological analysis on the region of interest. If `output_file_name` is provided, the results will be saved to a file.\n\n        Args:\n            input_dem_file (str): The path to the input DEM file.\n            output_file_name (str): The name of the output file to save the results. If None, the results will not be saved to a file.\n\n        Returns:\n            filled_file_name (str): The filled DEM raster file name.\n            d8_ptr_file_name (str): The D8 flow pointer raster file name.\n            flow_accum_file_name (str): The flow accumulation raster file name.\n        \"\"\"\n        # Retrieve DEM data\n        dem = self.wbe.read_raster(input_dem_file)\n\n        # Resolves all of the depressions in a DEM, outputting a breached DEM, an aspect-aligned non-divergent flow pointer, and a flow accumulation raster.\n\n        filled, d8_ptr, flow_accum = self.wbe.flow_accum_full_workflow(\n            dem=dem,\n            out_type=\"sca\",\n            log_transform=True,\n        )\n        base_file = os.path.basename(input_dem_file)\n        filled_file_name = f\"filled_{base_file}\"\n        d8_ptr_file_name = f\"d8_flow_{base_file}\"\n        flow_accum_file_name = f\"flow_{base_file}\"\n\n        self.wbe.write_raster(filled, f\"{filled_file_name}\")\n        self.wbe.write_raster(d8_ptr, f\"{d8_ptr_file_name}\")\n        self.wbe.write_raster(flow_accum, f\"{flow_accum_file_name}\")\n\n        return filled_file_name, d8_ptr_file_name, flow_accum_file_name\n\n    def add_analyse_roi_widget(self):\n        \"\"\"\n        Function to be run by widget to analyse the region of interest (ROI) for flood risk.\n\n        Args:\n            location (str): The location to check.\n\n        Returns:\n            None\n        \"\"\"\n        from ipywidgets import Dropdown, VBox, HBox, Button, Layout, Text, Output\n        from . import common\n\n        data_source = [\n            \"Sentinel-1\",\n            \"ALOS PALSAR\",\n        ]\n        debug_view = Output(\n            layout={\n                \"border\": \"1px solid black\",\n                \"overflow_x\": \"auto\",\n                \"width\": \"300px\",\n                \"height\": \"150px\",\n            }\n        )\n        debug_view.add_class(\"wrap-output\")\n        display(\n            HTML(\n                \"\"\"\n        &lt;style&gt;\n        .wrap-output {\n            width: 300px; \n            height: 150px; \n            overflow-x: hidden;   /* disable horizontal scroll */\n            overflow-y: auto;     /* enable vertical scroll */\n        }\n        .wrap-output pre {\n            white-space: pre-wrap !important;\n            word-wrap: break-word !important;\n        }\n        &lt;/style&gt;\n        \"\"\"\n            )\n        )\n\n        self.roi_name = Text(\n            value=\"\",\n            placeholder=\"Enter file name\",\n            description=\"ROI Name:\",\n            disabled=True,\n        )\n\n        self.file_name = Text(\n            value=\"\",\n            description=\"DEM File:\",\n            disabled=False,\n        )\n\n        self.dropdown = Dropdown(\n            options=data_source,\n            description=\"Data Source:\",\n            value=\"Sentinel-1\",\n            layout=Layout(width=\"auto\", display=\"block\"),\n            disabled=True,\n        )\n\n        self.submit_button = Button(\n            description=\"Submit\",\n            button_style=\"success\",\n            layout=Layout(width=\"auto\", display=\"block\"),\n            disabled=True,\n        )\n\n        self.analyze_button = Button(\n            description=\"Analyze DEM\",\n            button_style=\"success\",\n            layout=Layout(width=\"auto\", display=\"block\"),\n            disabled=True,\n        )\n\n        @debug_view.capture(clear_output=True)\n        def handle_submit(b):\n            print(\"Submit button clicked.\")\n            print(f\"Selected data source: {self.dropdown.value}\")\n            temp_file = f\"temp_{self.roi_name.value}\"\n            img = None\n            if self.dropdown.value == \"Sentinel-1\":\n                img = self.retrieve_sentinel_1_data_clip(\n                    self.user_roi, output_file_name=temp_file, scale=10\n                )\n            elif self.dropdown.value == \"ALOS PALSAR\":\n                img = self.retrieve_alos_palsar_data_clip(\n                    self.user_roi, output_file_name=temp_file, scale=30\n                )\n\n            self.add_ee_layer(img, name=f\"{self.dropdown.value} Image\")\n            temp_file = f\"{os.path.join(os.getcwd(),temp_file)}.tif\"\n            if temp_file != \"\" and os.path.isfile(temp_file):\n                # Fix for unsupported compression method when opening raster file in WBE\n                print(\"Reinstating compression method for the file...\")\n                self.file_name.value = common.fix_raster_metadata(\n                    temp_file, self.roi_name.value\n                )\n                self.file_name.disabled = False\n                self.analyze_button.disabled = False\n                print(f\"Done. File ready for analysis: {self.file_name.value}\")\n\n        @debug_view.capture(clear_output=True)\n        def handle_analyze(b):\n            print(\"Analyze button clicked.\")\n            print(f\"Processing File: {self.file_name.value}\")\n            filled, d8_ptr, flow_accum = self.perform_hydrological_analysis(\n                self.file_name.value\n            )\n            print(\"Hydrological analysis completed.\")\n\n            # Display results on the map\n            self.add_raster(filled, layer_name=\"Filled DEM\")\n            self.add_raster(d8_ptr, layer_name=\"D8 Flow Pointer\")\n            self.add_raster(\n                flow_accum, colormap=\"viridis\", layer_name=\"Flow Accumulation\"\n            )\n\n        def disable_widget(roi_count):\n            if roi_count == 1:\n                self.dropdown.disabled = False\n                self.roi_name.disabled = False\n                # self.submit_button.disabled = False\n                print(\n                    \"Region of interest defined. You can now select a data source and enter a file name.\"\n                )\n            else:\n                self.dropdown.disabled = True\n                self.roi_name.disabled = True\n                # self.submit_button.disabled = True\n                print(\"Please define a single region of interest first.\")\n\n        def handle_roi_name_change(change):\n            if change[\"new\"] != \"\":\n                self.submit_button.disabled = False\n            else:\n                self.submit_button.disabled = True\n\n        def handle_file_name_change(change):\n            if change[\"new\"] != \"\" and os.path.isfile(self.file_name.value):\n                self.analyze_button.disabled = False\n            else:\n                self.analyze_button.disabled = True\n\n        @debug_view.capture(clear_output=True)\n        def check_aoi(_, action, geo_json):\n            print(\"Checking region of interest...\")\n            print(f\"Action: {action}\")\n            roi_count = self.user_rois.size().getInfo()\n            if action == \"created\":\n                disable_widget(roi_count)\n            elif action == \"deleted\":\n                disable_widget(roi_count)\n\n        def toggle_dropdown(b):\n            if widget_vbox.layout.display == \"none\":\n                widget_vbox.layout.display = \"flex\"\n                btn.icon = \"times\"\n            else:\n                widget_vbox.layout.display = \"none\"\n                btn.icon = \"chevron-left\"\n\n        self.submit_button.on_click(handle_submit)\n        self.analyze_button.on_click(handle_analyze)\n        self.roi_name.observe(handle_roi_name_change, names=\"value\")\n        self.file_name.observe(handle_file_name_change, names=\"value\")\n        widget_vbox = VBox(\n            [\n                self.roi_name,\n                self.dropdown,\n                self.submit_button,\n                debug_view,\n                self.file_name,\n                self.analyze_button,\n            ],\n            Layout={\"overflow_x\": \"auto\", \"width\": \"300px\", \"height\": \"150px\"},\n        )\n        btn = Button(\n            icon=\"times\",\n            button_style=\"primary\",\n            layout=Layout(width=\"35px\", height=\"35px\"),\n        )\n        btn.on_click(toggle_dropdown)\n        widget_hbox = HBox([widget_vbox, btn], layout=Layout(width=\"auto\"))\n        self.add_widget(widget_hbox)\n        self.draw_control.on_draw(check_aoi)\n</code></pre>"},{"location":"road_flood_risk_map/#road_flood_risk_map.road_flood_risk_map.RoadFloodRiskMap.__init__","title":"<code>__init__(self, basemap='SATELLITE', center=[40, -100], zoom=4, height='600px', add_google_map=False, verbose=False)</code>  <code>special</code>","text":"<p>Initialize the RoadFloodRiskMap with map data.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>The basemap to use. Default is \"SATELLITE\". Other options include \"ROADMAP\", \"TERRAIN\", \"HYBRID\", etc.</p> <code>'SATELLITE'</code> <code>center</code> <code>list</code> <p>The center of the map as a list of [latitude, longitude]. Default is [40, -100].</p> <code>[40, -100]</code> <code>zoom</code> <code>int</code> <p>The initial zoom level of the map. Default is 4.</p> <code>4</code> <code>height</code> <code>str</code> <p>The height of the map in CSS units. Default is \"600px\".</p> <code>'600px'</code> <code>add_google_map</code> <code>bool</code> <p>Whether to add Google Maps basemap. Default is False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Default is False.</p> <code>False</code> Source code in <code>road_flood_risk_map/road_flood_risk_map.py</code> <pre><code>def __init__(\n    self,\n    basemap=\"SATELLITE\",\n    center=[40, -100],\n    zoom=4,\n    height=\"600px\",\n    add_google_map=False,\n    verbose=False,\n):\n    \"\"\"\n    Initialize the RoadFloodRiskMap with map data.\n\n    Args:\n        basemap (str): The basemap to use. Default is \"SATELLITE\". Other options include \"ROADMAP\", \"TERRAIN\", \"HYBRID\", etc.\n        center (list): The center of the map as a list of [latitude, longitude]. Default is [40, -100].\n        zoom (int): The initial zoom level of the map. Default is 4.\n        height (str): The height of the map in CSS units. Default is \"600px\".\n        add_google_map (bool): Whether to add Google Maps basemap. Default is False.\n        verbose (bool): Whether to print verbose output. Default is False.\n    \"\"\"\n    geemap.ee_initialize()  # Initialize Earth Engine\n    super().__init__(\n        basemap=basemap,\n        center=center,\n        zoom=zoom,\n        height=height,\n        add_google_map=add_google_map,\n    )\n    self.wbe = WbEnvironment()\n    self.wbe.verbose = verbose\n    self.wbe.working_directory = (\n        os.getcwd()\n    )  # Set the working directory to the current directory\n</code></pre>"},{"location":"road_flood_risk_map/#road_flood_risk_map.road_flood_risk_map.RoadFloodRiskMap.add_analyse_roi_widget","title":"<code>add_analyse_roi_widget(self)</code>","text":"<p>Function to be run by widget to analyse the region of interest (ROI) for flood risk.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>The location to check.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>road_flood_risk_map/road_flood_risk_map.py</code> <pre><code>def add_analyse_roi_widget(self):\n    \"\"\"\n    Function to be run by widget to analyse the region of interest (ROI) for flood risk.\n\n    Args:\n        location (str): The location to check.\n\n    Returns:\n        None\n    \"\"\"\n    from ipywidgets import Dropdown, VBox, HBox, Button, Layout, Text, Output\n    from . import common\n\n    data_source = [\n        \"Sentinel-1\",\n        \"ALOS PALSAR\",\n    ]\n    debug_view = Output(\n        layout={\n            \"border\": \"1px solid black\",\n            \"overflow_x\": \"auto\",\n            \"width\": \"300px\",\n            \"height\": \"150px\",\n        }\n    )\n    debug_view.add_class(\"wrap-output\")\n    display(\n        HTML(\n            \"\"\"\n    &lt;style&gt;\n    .wrap-output {\n        width: 300px; \n        height: 150px; \n        overflow-x: hidden;   /* disable horizontal scroll */\n        overflow-y: auto;     /* enable vertical scroll */\n    }\n    .wrap-output pre {\n        white-space: pre-wrap !important;\n        word-wrap: break-word !important;\n    }\n    &lt;/style&gt;\n    \"\"\"\n        )\n    )\n\n    self.roi_name = Text(\n        value=\"\",\n        placeholder=\"Enter file name\",\n        description=\"ROI Name:\",\n        disabled=True,\n    )\n\n    self.file_name = Text(\n        value=\"\",\n        description=\"DEM File:\",\n        disabled=False,\n    )\n\n    self.dropdown = Dropdown(\n        options=data_source,\n        description=\"Data Source:\",\n        value=\"Sentinel-1\",\n        layout=Layout(width=\"auto\", display=\"block\"),\n        disabled=True,\n    )\n\n    self.submit_button = Button(\n        description=\"Submit\",\n        button_style=\"success\",\n        layout=Layout(width=\"auto\", display=\"block\"),\n        disabled=True,\n    )\n\n    self.analyze_button = Button(\n        description=\"Analyze DEM\",\n        button_style=\"success\",\n        layout=Layout(width=\"auto\", display=\"block\"),\n        disabled=True,\n    )\n\n    @debug_view.capture(clear_output=True)\n    def handle_submit(b):\n        print(\"Submit button clicked.\")\n        print(f\"Selected data source: {self.dropdown.value}\")\n        temp_file = f\"temp_{self.roi_name.value}\"\n        img = None\n        if self.dropdown.value == \"Sentinel-1\":\n            img = self.retrieve_sentinel_1_data_clip(\n                self.user_roi, output_file_name=temp_file, scale=10\n            )\n        elif self.dropdown.value == \"ALOS PALSAR\":\n            img = self.retrieve_alos_palsar_data_clip(\n                self.user_roi, output_file_name=temp_file, scale=30\n            )\n\n        self.add_ee_layer(img, name=f\"{self.dropdown.value} Image\")\n        temp_file = f\"{os.path.join(os.getcwd(),temp_file)}.tif\"\n        if temp_file != \"\" and os.path.isfile(temp_file):\n            # Fix for unsupported compression method when opening raster file in WBE\n            print(\"Reinstating compression method for the file...\")\n            self.file_name.value = common.fix_raster_metadata(\n                temp_file, self.roi_name.value\n            )\n            self.file_name.disabled = False\n            self.analyze_button.disabled = False\n            print(f\"Done. File ready for analysis: {self.file_name.value}\")\n\n    @debug_view.capture(clear_output=True)\n    def handle_analyze(b):\n        print(\"Analyze button clicked.\")\n        print(f\"Processing File: {self.file_name.value}\")\n        filled, d8_ptr, flow_accum = self.perform_hydrological_analysis(\n            self.file_name.value\n        )\n        print(\"Hydrological analysis completed.\")\n\n        # Display results on the map\n        self.add_raster(filled, layer_name=\"Filled DEM\")\n        self.add_raster(d8_ptr, layer_name=\"D8 Flow Pointer\")\n        self.add_raster(\n            flow_accum, colormap=\"viridis\", layer_name=\"Flow Accumulation\"\n        )\n\n    def disable_widget(roi_count):\n        if roi_count == 1:\n            self.dropdown.disabled = False\n            self.roi_name.disabled = False\n            # self.submit_button.disabled = False\n            print(\n                \"Region of interest defined. You can now select a data source and enter a file name.\"\n            )\n        else:\n            self.dropdown.disabled = True\n            self.roi_name.disabled = True\n            # self.submit_button.disabled = True\n            print(\"Please define a single region of interest first.\")\n\n    def handle_roi_name_change(change):\n        if change[\"new\"] != \"\":\n            self.submit_button.disabled = False\n        else:\n            self.submit_button.disabled = True\n\n    def handle_file_name_change(change):\n        if change[\"new\"] != \"\" and os.path.isfile(self.file_name.value):\n            self.analyze_button.disabled = False\n        else:\n            self.analyze_button.disabled = True\n\n    @debug_view.capture(clear_output=True)\n    def check_aoi(_, action, geo_json):\n        print(\"Checking region of interest...\")\n        print(f\"Action: {action}\")\n        roi_count = self.user_rois.size().getInfo()\n        if action == \"created\":\n            disable_widget(roi_count)\n        elif action == \"deleted\":\n            disable_widget(roi_count)\n\n    def toggle_dropdown(b):\n        if widget_vbox.layout.display == \"none\":\n            widget_vbox.layout.display = \"flex\"\n            btn.icon = \"times\"\n        else:\n            widget_vbox.layout.display = \"none\"\n            btn.icon = \"chevron-left\"\n\n    self.submit_button.on_click(handle_submit)\n    self.analyze_button.on_click(handle_analyze)\n    self.roi_name.observe(handle_roi_name_change, names=\"value\")\n    self.file_name.observe(handle_file_name_change, names=\"value\")\n    widget_vbox = VBox(\n        [\n            self.roi_name,\n            self.dropdown,\n            self.submit_button,\n            debug_view,\n            self.file_name,\n            self.analyze_button,\n        ],\n        Layout={\"overflow_x\": \"auto\", \"width\": \"300px\", \"height\": \"150px\"},\n    )\n    btn = Button(\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=Layout(width=\"35px\", height=\"35px\"),\n    )\n    btn.on_click(toggle_dropdown)\n    widget_hbox = HBox([widget_vbox, btn], layout=Layout(width=\"auto\"))\n    self.add_widget(widget_hbox)\n    self.draw_control.on_draw(check_aoi)\n</code></pre>"},{"location":"road_flood_risk_map/#road_flood_risk_map.road_flood_risk_map.RoadFloodRiskMap.perform_hydrological_analysis","title":"<code>perform_hydrological_analysis(self, input_dem_file)</code>","text":"<p>Perform a hydrological analysis on the region of interest. If <code>output_file_name</code> is provided, the results will be saved to a file.</p> <p>Parameters:</p> Name Type Description Default <code>input_dem_file</code> <code>str</code> <p>The path to the input DEM file.</p> required <code>output_file_name</code> <code>str</code> <p>The name of the output file to save the results. If None, the results will not be saved to a file.</p> required <p>Returns:</p> Type Description <code>filled_file_name (str)</code> <p>The filled DEM raster file name. d8_ptr_file_name (str): The D8 flow pointer raster file name. flow_accum_file_name (str): The flow accumulation raster file name.</p> Source code in <code>road_flood_risk_map/road_flood_risk_map.py</code> <pre><code>def perform_hydrological_analysis(self, input_dem_file: str):\n    \"\"\"\n    Perform a hydrological analysis on the region of interest. If `output_file_name` is provided, the results will be saved to a file.\n\n    Args:\n        input_dem_file (str): The path to the input DEM file.\n        output_file_name (str): The name of the output file to save the results. If None, the results will not be saved to a file.\n\n    Returns:\n        filled_file_name (str): The filled DEM raster file name.\n        d8_ptr_file_name (str): The D8 flow pointer raster file name.\n        flow_accum_file_name (str): The flow accumulation raster file name.\n    \"\"\"\n    # Retrieve DEM data\n    dem = self.wbe.read_raster(input_dem_file)\n\n    # Resolves all of the depressions in a DEM, outputting a breached DEM, an aspect-aligned non-divergent flow pointer, and a flow accumulation raster.\n\n    filled, d8_ptr, flow_accum = self.wbe.flow_accum_full_workflow(\n        dem=dem,\n        out_type=\"sca\",\n        log_transform=True,\n    )\n    base_file = os.path.basename(input_dem_file)\n    filled_file_name = f\"filled_{base_file}\"\n    d8_ptr_file_name = f\"d8_flow_{base_file}\"\n    flow_accum_file_name = f\"flow_{base_file}\"\n\n    self.wbe.write_raster(filled, f\"{filled_file_name}\")\n    self.wbe.write_raster(d8_ptr, f\"{d8_ptr_file_name}\")\n    self.wbe.write_raster(flow_accum, f\"{flow_accum_file_name}\")\n\n    return filled_file_name, d8_ptr_file_name, flow_accum_file_name\n</code></pre>"},{"location":"road_flood_risk_map/#road_flood_risk_map.road_flood_risk_map.RoadFloodRiskMap.retrieve_alos_palsar_data_clip","title":"<code>retrieve_alos_palsar_data_clip(self, region_of_interest, output_file_name=None, scale=30)</code>","text":"<p>Retrieve ALOS PALSAR data clipped to a region of interest. If <code>output_file_name</code> is provided, the data will be saved to a file.</p> <p>Parameters:</p> Name Type Description Default <code>region_of_interest</code> <code>Geometry.BBox</code> <p>The region to clip the ALOS PALSAR data to. It follows the following format: <code>ee.Geometry.BBox(west, south, east, north)</code>. west The westernmost enclosed longitude. Will be adjusted to lie in the range -180\u00b0 to 180\u00b0. south The southernmost enclosed latitude. If less than -90\u00b0 (south pole), will be treated as -90\u00b0. east The easternmost enclosed longitude. north The northernmost enclosed latitude. If greater than +90\u00b0 (north pole), will be treated as +90\u00b0.</p> required <code>output_file_name</code> <code>str | None</code> <p>The name of the output file to save the data. If None, the data will not be saved to a file.</p> <code>None</code> <code>scale</code> <code>int</code> <p>The scale in meters at which to export the image. Default is 30.</p> <code>30</code> <p>Returns:</p> Type Description <code>image</code> <p>The ALOS PALSAR data clipped to the region of interest.</p> Source code in <code>road_flood_risk_map/road_flood_risk_map.py</code> <pre><code>def retrieve_alos_palsar_data_clip(\n    self,\n    region_of_interest: ee.Geometry,\n    output_file_name: str | None = None,\n    scale: int = 30,\n):\n    \"\"\"\n    Retrieve ALOS PALSAR data clipped to a region of interest. If `output_file_name` is provided, the data will be saved to a file.\n\n    Args:\n        region_of_interest (Geometry.BBox): The region to clip the ALOS PALSAR data to. It follows the following format: `ee.Geometry.BBox(west, south, east, north)`. **west** The westernmost enclosed longitude. Will be adjusted to lie in the range -180\u00b0 to 180\u00b0. **south** The southernmost enclosed latitude. If less than -90\u00b0 (south pole), will be treated as -90\u00b0. **east** The easternmost enclosed longitude. **north** The northernmost enclosed latitude. If greater than +90\u00b0 (north pole), will be treated as +90\u00b0.\n        output_file_name (str | None): The name of the output file to save the data. If None, the data will not be saved to a file.\n        scale (int): The scale in meters at which to export the image. Default is 30.\n\n    Returns:\n        image: The ALOS PALSAR data clipped to the region of interest.\n    \"\"\"\n    # Placeholder for actual data retrieval logic\n    sarHh = (\n        ee.ImageCollection(\"JAXA/ALOS/PALSAR/YEARLY/SAR_EPOCH\")\n        .filter(ee.Filter.date(\"2017-01-01\", \"2018-01-01\"))\n        .select(\"HH\")\n    )\n\n    if output_file_name != None or output_file_name != \"\":\n        try:\n            geemap.ee_export_image(\n                sarHh.mean(),\n                filename=output_file_name + \".tif\",\n                region=region_of_interest,\n                scale=scale,\n            )\n        except Exception as e:\n            print(f\"Error exporting image: {e}\")\n\n    return sarHh.mean().clip(region_of_interest)\n</code></pre>"},{"location":"road_flood_risk_map/#road_flood_risk_map.road_flood_risk_map.RoadFloodRiskMap.retrieve_sentinel_1_data_clip","title":"<code>retrieve_sentinel_1_data_clip(self, region_of_interest, output_file_name=None, scale=30)</code>","text":"<p>Retrieve Sentinel-1 data clipped to a region of interest. If <code>output_file_name</code> is provided, the data will be saved to a file.</p> <p>Parameters:</p> Name Type Description Default <code>region_of_interest</code> <code>Geometry.BBox</code> <p>The region to clip the Sentinel-1 data to. It follows the following format: <code>ee.Geometry.BBox(west, south, east, north)</code>. west The westernmost enclosed longitude. Will be adjusted to lie in the range -180\u00b0 to 180\u00b0. south The southernmost enclosed latitude. If less than -90\u00b0 (south pole), will be treated as -90\u00b0. east The easternmost enclosed longitude. north The northernmost enclosed latitude. If greater than +90\u00b0 (north pole), will be treated as +90\u00b0.</p> required <code>output_file_name</code> <code>str | None</code> <p>The name of the output file to save the data. If None, the data will not be saved to a file.</p> <code>None</code> <code>scale</code> <code>int</code> <p>The scale in meters at which to export the image. Default is 30.</p> <code>30</code> <p>Returns:</p> Type Description <code>image</code> <p>The Sentinel-1 data clipped to the region of interest.</p> Source code in <code>road_flood_risk_map/road_flood_risk_map.py</code> <pre><code>def retrieve_sentinel_1_data_clip(\n    self,\n    region_of_interest: ee.Geometry,\n    output_file_name: str | None = None,\n    scale: int = 30,\n):\n    \"\"\"\n    Retrieve Sentinel-1 data clipped to a region of interest. If `output_file_name` is provided, the data will be saved to a file.\n\n    Args:\n        region_of_interest (Geometry.BBox): The region to clip the Sentinel-1 data to. It follows the following format: `ee.Geometry.BBox(west, south, east, north)`. **west** The westernmost enclosed longitude. Will be adjusted to lie in the range -180\u00b0 to 180\u00b0. **south** The southernmost enclosed latitude. If less than -90\u00b0 (south pole), will be treated as -90\u00b0. **east** The easternmost enclosed longitude. **north** The northernmost enclosed latitude. If greater than +90\u00b0 (north pole), will be treated as +90\u00b0.\n        output_file_name (str | None): The name of the output file to save the data. If None, the data will not be saved to a file.\n        scale (int): The scale in meters at which to export the image. Default is 30.\n\n    Returns:\n        image: The Sentinel-1 data clipped to the region of interest.\n    \"\"\"\n    # Placeholder for actual data retrieval logic\n    sentinel1 = (\n        ee.ImageCollection(\"COPERNICUS/S1_GRD\")\n        .filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VH\"))\n        .filter(ee.Filter.date(\"2024-06-01\", \"2025-06-01\"))\n        .filter(ee.Filter.eq(\"resolution_meters\", scale))\n        .select(\"VH\")\n    )\n\n    if output_file_name != None and output_file_name != \"\":\n        try:\n            geemap.ee_export_image(\n                sentinel1.mean(),\n                filename=output_file_name + \".tif\",\n                region=region_of_interest,\n                scale=scale,\n            )\n        except Exception as e:\n            print(f\"Error exporting image: {e}\")\n\n    return sentinel1.mean().clip(region_of_interest)\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use road-flood-risk-map in a project:</p> <pre><code>import road_flood_risk_map\n</code></pre>"}]}